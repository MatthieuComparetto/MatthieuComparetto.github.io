---
title: ''
output: html_document
---

exemple: classification des points dans le plan


Dans cette partie, nous simulons des impacts de balles provenant de deux tireurs différents. Nous présentons une procédure de détection des impacts de chaque tireurs. Cela revient à mettre une couleur noir ou rouge sur chaque impact où chaque couleur caractérise un tireur. Le bloc de code suivant propose de simuler 200 impacts sur un mur. Ces lignes de code ont été réalisées sous le logiciel libre [\textsf{R}](https://cran.r-project.org/). Les principaux éléments de ce codes correspondent à 
 
 - l'instruction `set.seed(123)` permet de rendre l'expérience de simulation reproductible
 - l'objet intitulé `rmixture` qui simule les impacts de balles où 
    - `n` est l'agrument qui contrôle le nombre d'impacts à simuler
    - `delta` contrôle la différence entre les impacts des deux tireurs
    - `d.disc` est le nombe de dimensions discriminantes (une seule dans notre exemple)
    - `d.nondisc` est le nombe de dimensions non-discriminantes (une seule dans notre exemple)

Dans la suite, nous allons utiliser le terme *étiquette* pour désigner les couleurs rouge et noir qui permettent de distinguer les impacts d'un tireur de ceux de l'autre.
On propose de cacher la vérité qui correspond aux étiquettes rouges et noirs des impacts et nous allons faire appel à une procédure de détection appelée **algorithme des k-moyennes**.

```{r, eval=TRUE, fig.height=5.5, fig.width=5.5}
set.seed(123)
# Fonction de generation des donnees
rmixture <- function(n, delta, d.disc, d.nondisc){
  z <- sample(1:2, n, replace = TRUE)
  x <- matrix(rnorm(n*(d.disc+d.nondisc)), n)
  x[which(z==2), 1:d.disc] <- x[which(z==2), 1:d.disc]*2 + delta
  list(x=as.data.frame(x), z=z)
}


ech <- rmixture(n=200, delta=5, d.disc = 1, d.nondisc = 1)
plot(ech$x[,1], ech$x[,2], pch="+", col=ech$z, xlab=~x, ylab=~y, main="la vérité simulée")
```


L'algorithme des k-moyennes peut être résumé par les 4 étapes suivantes : 

1. On choisit deux points moyens au hasard, un rouge et un noir. 

2. On affecte une étiquette rouges aux points les plus proches du point rouge et une étiquette noir aux points les plus proches du point noir;

3. On calcule les coordonnées moyennes des points rouges et les coordonnées moyennes des points noirs qui vont jouer le rôle des deux points moyens rouge et noir.

4. On répete l'etape 2 et 3 jusqu'à ce que les deux points moyens rouge et noir se stabilisent et ne bougent plus.


<!-- L’algorithme ci dessous détecte la provenances des impacts de balles; On considère un tireur qui aura ses balles en noirs et un autre avec des balles en rouges. L’algorithme à 5.5% de chance de se tromper. Comme on peut voir sur le graphique, il ne suffit que d'une seule dimension pour distinguer le milieu des impacts de balles(Y) -->
<!-- grâce à l'algorithme on peut aussi savoir quel est le côté discriminant et le aussi nombre de tireur. -->
Le bloc de code suivant permet de mettre en place la procédure des kmoyennes sur les
200 impacts simulés précédemment

```{r, eval=TRUE}
par(mfrow=c(1,2))
plot(ech$x[,1], ech$x[,2], pch="+", xlab=~x, ylab=~y, main="étiquettes cachées")
detect <- kmeans(ech$x, 2, nstart = 100)
plot(ech$x[,1], ech$x[,2], pch="+", col = detect$cluster,
     xlab=~x, ylab=~y, main="étiquettes attribuées")
min(mean(ech$z!=detect$cluster), 1-mean(ech$z!=detect$cluster))
```
Comme on peut le constacter, l'affectation des couleurs des étiquettes se fait à une permutation près. L'algorithme des k-moyennes se trompes dans l'étiquetage de $5.5\%$
des impacts.

On Utilise maintenat une autre figure ci dessous. on peut voir deux formes distinct. On essaye maitenant de la séparer avec Kmoyenne

```{r, eval=TRUE, fig.height=5.5, fig.width=5.5}
require(kernlab)
data(spirals)
plot(spirals, xlab=~x, ylab=~y, main="deux spirales")
```

Comme on peut voir Kmoyenne, échoue complétement en séparant les spirales en leur milieu.
On utilise alors specc pour les séparer et comme on peut voir sur l'image juste en dessous, arrive à séparer correctement les spirales.
```{r, eval=TRUE}
require(kernlab)
data(spirals)
par(mfrow=c(1,2))
plot(spirals, col = kmeans(spirals, 2)$cluster, xlab=~x, ylab=~y )
plot(spirals, col = specc(spirals, 2), xlab=~x, ylab=~y)
```


